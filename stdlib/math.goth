# Goth Standard Library - Mathematical Functions
# Advanced mathematical operations beyond the prelude basics
#
# Built-in math functions available:
#   Arithmetic: +, -, Ã—, /, %, ^
#   Roots: âˆš (sqrt)
#   Exponential: exp, ln, logâ‚â‚€, logâ‚‚
#   Trigonometric: sin, cos, tan, asin, acos, atan
#   Hyperbolic: sinh, cosh, tanh
#   Rounding: âŒŠâŒ‹ (floor), âŒˆâŒ‰ (ceil), round
#   Special: Î“ (gamma function), abs, sign
#
# Note: Some algorithms (gcd, factorial) that typically use recursion
# are implemented using closed-form solutions or iterative approaches
# due to interpreter limitations with multi-argument recursion.

# ============ Constants ============

# Pi (also built-in as Ï€)
let pi = 3.14159265358979323846

# Euler's number e (also built-in as ğ•–)
let euler = 2.71828182845904523536

# Golden ratio Ï†
let goldenRatio = (1.0 + âˆš5.0) / 2.0

# Square root of 2
let sqrtTwo = âˆš2.0

# Square root of 3
let sqrtThree = âˆš3.0

# Natural log of 2
let lnTwo = ln 2.0

# Natural log of 10
let lnTen = ln 10.0

# ============ Basic Operations ============

# Absolute value (integer)
â•­â”€ absI : â„¤ â†’ â„¤
â•°â”€ if â‚€ < 0 then 0 - â‚€ else â‚€

# Absolute value (float)
â•­â”€ absF : F â†’ F
â•°â”€ if â‚€ < 0.0 then 0.0 - â‚€ else â‚€

# Sign function (integer): returns -1, 0, or 1
â•­â”€ signI : â„¤ â†’ â„¤
â•°â”€ if â‚€ < 0 then -1 else if â‚€ > 0 then 1 else 0

# Sign function (float): returns -1.0, 0.0, or 1.0
â•­â”€ signF : F â†’ F
â•°â”€ if â‚€ < 0.0 then -1.0 else if â‚€ > 0.0 then 1.0 else 0.0

# Copy sign: magnitude of first, sign of second
â•­â”€ copySign : F â†’ F â†’ F
â•°â”€ if â‚€ < 0.0 then 0.0 - (if â‚ < 0.0 then 0.0 - â‚ else â‚)
   else (if â‚ < 0.0 then 0.0 - â‚ else â‚)

# ============ Power and Root Functions ============

# Integer power (for small non-negative exponents)
# Uses: base^exp via built-in ^
â•­â”€ pow : F â†’ F â†’ F
â•°â”€ â‚ ^ â‚€

# Square
â•­â”€ sq : F â†’ F
â•°â”€ â‚€ Ã— â‚€

# Cube
â•­â”€ cb : F â†’ F
â•°â”€ â‚€ Ã— â‚€ Ã— â‚€

# Fourth power
â•­â”€ pow4 : F â†’ F
â•°â”€ let x2 = â‚€ Ã— â‚€ in x2 Ã— x2

# Square root (alias for âˆš)
â•­â”€ sqrt : F â†’ F
â•°â”€ âˆšâ‚€

# Cube root
â•­â”€ cbrt : F â†’ F
â•°â”€ if â‚€ < 0.0 then 0.0 - ((0.0 - â‚€) ^ (1.0 / 3.0))
   else â‚€ ^ (1.0 / 3.0)

# Nth root
â•­â”€ nthRoot : F â†’ F â†’ F
â•°â”€ â‚€ ^ (1.0 / â‚)

# Hypotenuse: sqrt(aÂ² + bÂ²) - more numerically stable
â•­â”€ hypot : F â†’ F â†’ F
â•°â”€ âˆš(â‚ Ã— â‚ + â‚€ Ã— â‚€)

# ============ Exponential and Logarithmic ============

# Exponential (alias)
â•­â”€ exp : F â†’ F
â•°â”€ ğ•– ^ â‚€

# Natural log (alias)
â•­â”€ log : F â†’ F
â•°â”€ ln â‚€

# Log base 10 (alias)
â•­â”€ log10 : F â†’ F
â•°â”€ logâ‚â‚€ â‚€

# Log base 2 (alias)
â•­â”€ log2 : F â†’ F
â•°â”€ logâ‚‚ â‚€

# Log with arbitrary base
â•­â”€ logBase : F â†’ F â†’ F
â•°â”€ ln â‚€ / ln â‚

# exp(x) - 1, more accurate for small x
â•­â”€ expm1 : F â†’ F
â•°â”€ exp â‚€ - 1.0

# log(1 + x), more accurate for small x
â•­â”€ log1p : F â†’ F
â•°â”€ ln (1.0 + â‚€)

# 2^x
â•­â”€ exp2 : F â†’ F
â•°â”€ 2.0 ^ â‚€

# 10^x
â•­â”€ exp10 : F â†’ F
â•°â”€ 10.0 ^ â‚€

# ============ Trigonometric Functions ============

# Basic trig (built-in: sin, cos, tan, asin, acos, atan)

# Secant
â•­â”€ sec : F â†’ F
â•°â”€ 1.0 / cos â‚€

# Cosecant
â•­â”€ csc : F â†’ F
â•°â”€ 1.0 / sin â‚€

# Cotangent
â•­â”€ cot : F â†’ F
â•°â”€ cos â‚€ / sin â‚€

# Two-argument arctangent (atan2)
â•­â”€ atan2 : F â†’ F â†’ F
â•°â”€ if â‚€ > 0.0 then atan (â‚ / â‚€)
   else if â‚€ < 0.0 âˆ§ â‚ â‰¥ 0.0 then atan (â‚ / â‚€) + Ï€
   else if â‚€ < 0.0 âˆ§ â‚ < 0.0 then atan (â‚ / â‚€) - Ï€
   else if â‚€ = 0.0 âˆ§ â‚ > 0.0 then Ï€ / 2.0
   else if â‚€ = 0.0 âˆ§ â‚ < 0.0 then 0.0 - Ï€ / 2.0
   else 0.0

# Sine squared
â•­â”€ sin2 : F â†’ F
â•°â”€ let s = sin â‚€ in s Ã— s

# Cosine squared
â•­â”€ cos2 : F â†’ F
â•°â”€ let c = cos â‚€ in c Ã— c

# Sinc function: sin(x)/x, with sinc(0) = 1
â•­â”€ sinc : F â†’ F
â•°â”€ if â‚€ = 0.0 then 1.0 else sin â‚€ / â‚€

# ============ Angle Conversion ============

# Degrees to radians
â•­â”€ degToRad : F â†’ F
â•°â”€ â‚€ Ã— Ï€ / 180.0

# Radians to degrees
â•­â”€ radToDeg : F â†’ F
â•°â”€ â‚€ Ã— 180.0 / Ï€

# Normalize angle to [0, 2Ï€)
â•­â”€ normalizeAngle : F â†’ F
â•°â”€ let tau = 2.0 Ã— Ï€
   in â‚€ - tau Ã— âŒŠâ‚€ / tauâŒ‹

# Normalize angle to [-Ï€, Ï€)
â•­â”€ normalizeAngleSigned : F â†’ F
â•°â”€ let tau = 2.0 Ã— Ï€
   in let a = â‚€ - tau Ã— âŒŠâ‚€ / tauâŒ‹
   in if a â‰¥ Ï€ then a - tau else a

# ============ Hyperbolic Functions ============

# Built-in: sinh, cosh, tanh

# Hyperbolic secant
â•­â”€ sech : F â†’ F
â•°â”€ 1.0 / cosh â‚€

# Hyperbolic cosecant
â•­â”€ csch : F â†’ F
â•°â”€ 1.0 / sinh â‚€

# Hyperbolic cotangent
â•­â”€ coth : F â†’ F
â•°â”€ cosh â‚€ / sinh â‚€

# Inverse hyperbolic sine
â•­â”€ asinh : F â†’ F
â•°â”€ ln (â‚€ + âˆš(â‚€ Ã— â‚€ + 1.0))

# Inverse hyperbolic cosine
â•­â”€ acosh : F â†’ F
â•°â”€ ln (â‚€ + âˆš(â‚€ Ã— â‚€ - 1.0))

# Inverse hyperbolic tangent
â•­â”€ atanh : F â†’ F
â•°â”€ 0.5 Ã— ln ((1.0 + â‚€) / (1.0 - â‚€))

# ============ Number Theory (Integer) ============

# Check if even
â•­â”€ isEven : â„¤ â†’ Bool
â•°â”€ â‚€ % 2 = 0

# Check if odd
â•­â”€ isOdd : â„¤ â†’ Bool
â•°â”€ â‚€ % 2 â‰  0

# Check if divisible
â•­â”€ divides : â„¤ â†’ â„¤ â†’ Bool
â•°â”€ â‚€ % â‚ = 0

# Integer division (floor division)
â•­â”€ floorDiv : â„¤ â†’ â„¤ â†’ â„¤
â•°â”€ â‚ / â‚€

# Modulo (always non-negative for positive divisor)
â•­â”€ mod : â„¤ â†’ â„¤ â†’ â„¤
â•°â”€ let r = â‚ % â‚€
   in if r < 0 then r + â‚€ else r

# Quotient and remainder as pair
â•­â”€ quotRem : â„¤ â†’ â„¤ â†’ âŸ¨â„¤, â„¤âŸ©
â•°â”€ âŸ¨â‚ / â‚€, â‚ % â‚€âŸ©

# ============ Factorial and Combinatorics ============

# Factorial using gamma function: n! = Î“(n+1)
â•­â”€ factorial : â„¤ â†’ F
â•°â”€ Î“ (toFloat â‚€ + 1.0)

# Double factorial approximation for small values
# n!! = n Ã— (n-2) Ã— (n-4) Ã— ...
â•­â”€ doubleFactorial : â„¤ â†’ F
â•°â”€ if â‚€ â‰¤ 0 then 1.0
   else if â‚€ % 2 = 0 then
     # Even: 2^(n/2) Ã— (n/2)!
     let k = â‚€ / 2
     in (2.0 ^ toFloat k) Ã— Î“ (toFloat k + 1.0)
   else
     # Odd: n! / (n/2)! / 2^(n/2) where n/2 is floor
     Î“ (toFloat â‚€ + 1.0) / (Î“ (toFloat (â‚€ / 2) + 1.0) Ã— (2.0 ^ toFloat (â‚€ / 2)))

# Binomial coefficient C(n,k) = n! / (k! Ã— (n-k)!)
# Using gamma function for numerical stability
â•­â”€ binomial : â„¤ â†’ â„¤ â†’ F
â•°â”€ if â‚€ < 0 âˆ¨ â‚€ > â‚ then 0.0
   else Î“ (toFloat â‚ + 1.0) / (Î“ (toFloat â‚€ + 1.0) Ã— Î“ (toFloat (â‚ - â‚€) + 1.0))

# Permutations P(n,k) = n! / (n-k)!
â•­â”€ permutations : â„¤ â†’ â„¤ â†’ F
â•°â”€ if â‚€ < 0 âˆ¨ â‚€ > â‚ then 0.0
   else Î“ (toFloat â‚ + 1.0) / Î“ (toFloat (â‚ - â‚€) + 1.0)

# ============ Special Functions ============

# Gamma function (built-in as Î“)
â•­â”€ gamma : F â†’ F
â•°â”€ Î“ â‚€

# Log-gamma function (more stable for large values)
â•­â”€ lgamma : F â†’ F
â•°â”€ ln (Î“ â‚€)

# Beta function: B(a,b) = Î“(a)Î“(b)/Î“(a+b)
â•­â”€ beta : F â†’ F â†’ F
â•°â”€ Î“ â‚ Ã— Î“ â‚€ / Î“ (â‚ + â‚€)

# Error function approximation (using tanh approximation)
â•­â”€ erf : F â†’ F
â•°â”€ let x = â‚€
   in let t = 1.0 / (1.0 + 0.5 Ã— (if x < 0.0 then 0.0 - x else x))
   in let tau = t Ã— exp (0.0 - x Ã— x - 1.26551223 +
        t Ã— (1.00002368 + t Ã— (0.37409196 + t Ã— (0.09678418 +
        t Ã— (-0.18628806 + t Ã— (0.27886807 + t Ã— (-1.13520398 +
        t Ã— (1.48851587 + t Ã— (-0.82215223 + t Ã— 0.17087277)))))))))
   in if x â‰¥ 0.0 then 1.0 - tau else tau - 1.0

# Complementary error function
â•­â”€ erfc : F â†’ F
â•°â”€ 1.0 - erf â‚€

# ============ Rounding and Remainder ============

# Floor (built-in as âŒŠâŒ‹)
â•­â”€ floor : F â†’ F
â•°â”€ âŒŠâ‚€âŒ‹

# Ceiling (built-in as âŒˆâŒ‰)
â•­â”€ ceil : F â†’ F
â•°â”€ âŒˆâ‚€âŒ‰

# Round to nearest integer
â•­â”€ round : F â†’ F
â•°â”€ âŒŠâ‚€ + 0.5âŒ‹

# Round away from zero
â•­â”€ roundAwayFromZero : F â†’ F
â•°â”€ if â‚€ â‰¥ 0.0 then âŒˆâ‚€âŒ‰ else âŒŠâ‚€âŒ‹

# Truncate toward zero
â•­â”€ trunc : F â†’ F
â•°â”€ if â‚€ â‰¥ 0.0 then âŒŠâ‚€âŒ‹ else âŒˆâ‚€âŒ‰

# Fractional part (always positive)
â•­â”€ frac : F â†’ F
â•°â”€ â‚€ - âŒŠâ‚€âŒ‹

# Round to n decimal places
â•­â”€ roundTo : â„¤ â†’ F â†’ F
â•°â”€ let scale = 10.0 ^ toFloat â‚
   in âŒŠâ‚€ Ã— scale + 0.5âŒ‹ / scale

# ============ Comparison and Bounds ============

# Minimum of two floats
â•­â”€ minF : F â†’ F â†’ F
â•°â”€ if â‚ < â‚€ then â‚ else â‚€

# Maximum of two floats
â•­â”€ maxF : F â†’ F â†’ F
â•°â”€ if â‚ > â‚€ then â‚ else â‚€

# Minimum of two integers
â•­â”€ minI : â„¤ â†’ â„¤ â†’ â„¤
â•°â”€ if â‚ < â‚€ then â‚ else â‚€

# Maximum of two integers
â•­â”€ maxI : â„¤ â†’ â„¤ â†’ â„¤
â•°â”€ if â‚ > â‚€ then â‚ else â‚€

# Clamp value to range [lo, hi]
â•­â”€ clamp : F â†’ F â†’ F â†’ F
â•°â”€ if â‚€ < â‚‚ then â‚‚ else if â‚€ > â‚ then â‚ else â‚€

# Clamp integer to range
â•­â”€ clampI : â„¤ â†’ â„¤ â†’ â„¤ â†’ â„¤
â•°â”€ if â‚€ < â‚‚ then â‚‚ else if â‚€ > â‚ then â‚ else â‚€

# ============ Interpolation ============

# Linear interpolation: lerp(t, a, b) = a + t*(b-a)
â•­â”€ lerp : F â†’ F â†’ F â†’ F
â•°â”€ â‚ + â‚‚ Ã— (â‚€ - â‚)

# Inverse lerp: find t such that lerp(t,a,b) = x
â•­â”€ invLerp : F â†’ F â†’ F â†’ F
â•°â”€ (â‚€ - â‚‚) / (â‚ - â‚‚)

# Remap value from one range to another
â•­â”€ remap : F â†’ F â†’ F â†’ F â†’ F â†’ F
â•°â”€ let t = (â‚€ - â‚„) / (â‚ƒ - â‚„)
   in â‚‚ + t Ã— (â‚ - â‚‚)

# Smooth step (cubic Hermite interpolation)
â•­â”€ smoothstep : F â†’ F â†’ F â†’ F
â•°â”€ let t = if â‚€ â‰¤ â‚‚ then 0.0 else if â‚€ â‰¥ â‚ then 1.0 else (â‚€ - â‚‚) / (â‚ - â‚‚)
   in t Ã— t Ã— (3.0 - 2.0 Ã— t)

# Smoother step (quintic interpolation)
â•­â”€ smootherstep : F â†’ F â†’ F â†’ F
â•°â”€ let t = if â‚€ â‰¤ â‚‚ then 0.0 else if â‚€ â‰¥ â‚ then 1.0 else (â‚€ - â‚‚) / (â‚ - â‚‚)
   in t Ã— t Ã— t Ã— (t Ã— (t Ã— 6.0 - 15.0) + 10.0)

# ============ Geometry (2D) ============

# Distance between two points
â•­â”€ distance2D : F â†’ F â†’ F â†’ F â†’ F
â•°â”€ let dx = â‚‚ - â‚€
   in let dy = â‚ƒ - â‚
   in âˆš(dx Ã— dx + dy Ã— dy)

# Squared distance (avoids sqrt)
â•­â”€ distanceSq2D : F â†’ F â†’ F â†’ F â†’ F
â•°â”€ let dx = â‚‚ - â‚€
   in let dy = â‚ƒ - â‚
   in dx Ã— dx + dy Ã— dy

# Midpoint between two points
â•­â”€ midpoint2D : F â†’ F â†’ F â†’ F â†’ âŸ¨F, FâŸ©
â•°â”€ âŸ¨(â‚ƒ + â‚) / 2.0, (â‚‚ + â‚€) / 2.0âŸ©

# Angle from origin to point (in radians)
â•­â”€ angle2D : F â†’ F â†’ F
â•°â”€ atan2 â‚€ â‚

# ============ Geometry (3D) ============

# Distance in 3D
â•­â”€ distance3D : F â†’ F â†’ F â†’ F â†’ F â†’ F â†’ F
â•°â”€ let dx = â‚ƒ - â‚€
   in let dy = â‚„ - â‚
   in let dz = â‚… - â‚‚
   in âˆš(dx Ã— dx + dy Ã— dy + dz Ã— dz)

# Squared distance in 3D
â•­â”€ distanceSq3D : F â†’ F â†’ F â†’ F â†’ F â†’ F â†’ F
â•°â”€ let dx = â‚ƒ - â‚€
   in let dy = â‚„ - â‚
   in let dz = â‚… - â‚‚
   in dx Ã— dx + dy Ã— dy + dz Ã— dz

# ============ Statistics (Single Values) ============

# Standard normal PDF: Ï†(x) = exp(-xÂ²/2) / âˆš(2Ï€)
â•­â”€ normalPDF : F â†’ F
â•°â”€ exp (0.0 - â‚€ Ã— â‚€ / 2.0) / âˆš(2.0 Ã— Ï€)

# Standard normal CDF approximation
â•­â”€ normalCDF : F â†’ F
â•°â”€ 0.5 Ã— (1.0 + erf (â‚€ / âˆš2.0))

# General normal PDF with mean Î¼ and std Ïƒ
â•­â”€ gaussianPDF : F â†’ F â†’ F â†’ F
â•°â”€ let z = (â‚€ - â‚‚) / â‚
   in exp (0.0 - z Ã— z / 2.0) / (â‚ Ã— âˆš(2.0 Ã— Ï€))

# ============ Numerical Utilities ============

# Check if approximately equal (within epsilon)
â•­â”€ approxEq : F â†’ F â†’ F â†’ Bool
â•°â”€ let diff = â‚ - â‚‚
   in (if diff < 0.0 then 0.0 - diff else diff) < â‚€

# Check if approximately zero
â•­â”€ approxZero : F â†’ F â†’ Bool
â•°â”€ (if â‚€ < 0.0 then 0.0 - â‚€ else â‚€) < â‚

# Relative error
â•­â”€ relativeError : F â†’ F â†’ F
â•°â”€ if â‚€ = 0.0 then (if â‚ < 0.0 then 0.0 - â‚ else â‚)
   else let diff = â‚ - â‚€
        in (if diff < 0.0 then 0.0 - diff else diff) / (if â‚€ < 0.0 then 0.0 - â‚€ else â‚€)

# Machine epsilon (approximate)
let epsilon = 2.220446049250313e-16

# Check if finite (not inf or nan) - approximation
â•­â”€ isFinite : F â†’ Bool
â•°â”€ â‚€ = â‚€ âˆ§ â‚€ - â‚€ = 0.0

# ============ Polynomial Evaluation ============

# Evaluate polynomial using Horner's method
# coeffs are [aâ‚€, aâ‚, aâ‚‚, ...] for aâ‚€ + aâ‚x + aâ‚‚xÂ² + ...
â•­â”€ polyEval : [n]F â†’ F â†’ F
â•°â”€ let coeffs = reverse â‚
   in if len coeffs = 0 then 0.0
   else let result = coeffs â†¦ Î»â†’ â‚€
        in Î£ (iota (len coeffs) â†¦ Î»â†’ â‚‚[â‚€] Ã— (â‚ ^ toFloat â‚€))
