# Goth Standard Library - Prelude
# Core functions imported by default
#
# This module provides fundamental operations that are useful across
# all Goth programs. It includes combinators, boolean logic, numeric
# operations, and basic utility functions.

# ============ Core Combinators ============

# Identity function: returns its argument unchanged
â•­â”€ id : Î± â†’ Î±
â•°â”€ â‚€

# Constant function: returns first argument, ignores second
â•­â”€ const : Î± â†’ Î² â†’ Î±
â•°â”€ â‚

# Flip arguments of a binary function
â•­â”€ flip : (Î± â†’ Î² â†’ Î³) â†’ Î² â†’ Î± â†’ Î³
â•°â”€ â‚‚ â‚€ â‚

# Function composition: (f âˆ˜ g)(x) = f(g(x))
â•­â”€ compose : (Î² â†’ Î³) â†’ (Î± â†’ Î²) â†’ Î± â†’ Î³
â•°â”€ â‚‚ (â‚ â‚€)

# Apply function to argument (flip of $)
â•­â”€ apply : Î± â†’ (Î± â†’ Î²) â†’ Î²
â•°â”€ â‚€ â‚

# Apply argument to function (flip of apply)
â•­â”€ applyTo : (Î± â†’ Î²) â†’ Î± â†’ Î²
â•°â”€ â‚ â‚€

# On combinator: (f `on` g) x y = f (g x) (g y)
â•­â”€ on : (Î² â†’ Î² â†’ Î³) â†’ (Î± â†’ Î²) â†’ Î± â†’ Î± â†’ Î³
â•°â”€ â‚ƒ (â‚‚ â‚) (â‚‚ â‚€)

# ============ Boolean Operations ============

# Logical NOT
â•­â”€ not : Bool â†’ Bool
â•°â”€ if â‚€ then âŠ¥ else âŠ¤

# Logical AND
â•­â”€ and : Bool â†’ Bool â†’ Bool
â•°â”€ if â‚ then â‚€ else âŠ¥

# Logical OR
â•­â”€ or : Bool â†’ Bool â†’ Bool
â•°â”€ if â‚ then âŠ¤ else â‚€

# Logical XOR (exclusive or)
â•­â”€ xor : Bool â†’ Bool â†’ Bool
â•°â”€ if â‚ then (if â‚€ then âŠ¥ else âŠ¤) else â‚€

# Logical NAND
â•­â”€ nand : Bool â†’ Bool â†’ Bool
â•°â”€ if â‚ then (if â‚€ then âŠ¥ else âŠ¤) else âŠ¤

# Logical NOR
â•­â”€ nor : Bool â†’ Bool â†’ Bool
â•°â”€ if â‚ then âŠ¥ else (if â‚€ then âŠ¥ else âŠ¤)

# Logical implication: a â†’ b (if a then b, else true)
â•­â”€ implies : Bool â†’ Bool â†’ Bool
â•°â”€ if â‚ then â‚€ else âŠ¤

# Logical equivalence (XNOR)
â•­â”€ iff : Bool â†’ Bool â†’ Bool
â•°â”€ if â‚ then â‚€ else (if â‚€ then âŠ¥ else âŠ¤)

# Boolean to integer (âŠ¥ = 0, âŠ¤ = 1)
â•­â”€ boolToInt : Bool â†’ â„¤
â•°â”€ if â‚€ then 1 else 0

# Integer to boolean (0 = âŠ¥, else âŠ¤)
â•­â”€ intToBool : â„¤ â†’ Bool
â•°â”€ â‚€ â‰  0

# ============ Comparison Operations ============

# Minimum of two values
â•­â”€ min : F â†’ F â†’ F
â•°â”€ if â‚ < â‚€ then â‚ else â‚€

# Maximum of two values
â•­â”€ max : F â†’ F â†’ F
â•°â”€ if â‚ > â‚€ then â‚ else â‚€

# Clamp value to range [lo, hi]
â•­â”€ clamp : F â†’ F â†’ F â†’ F
â•°â”€ if â‚€ < â‚‚ then â‚‚
   else if â‚€ > â‚ then â‚
   else â‚€

# Check if value is in range [lo, hi] (inclusive)
â•­â”€ between : F â†’ F â†’ F â†’ Bool
â•°â”€ â‚€ â‰¥ â‚‚ âˆ§ â‚€ â‰¤ â‚

# Check if value is in range (lo, hi) (exclusive)
â•­â”€ betweenExcl : F â†’ F â†’ F â†’ Bool
â•°â”€ â‚€ > â‚‚ âˆ§ â‚€ < â‚

# Integer minimum
â•­â”€ minInt : â„¤ â†’ â„¤ â†’ â„¤
â•°â”€ if â‚ < â‚€ then â‚ else â‚€

# Integer maximum
â•­â”€ maxInt : â„¤ â†’ â„¤ â†’ â„¤
â•°â”€ if â‚ > â‚€ then â‚ else â‚€

# ============ Numeric Predicates ============

# Check if zero
â•­â”€ isZero : â„¤ â†’ Bool
â•°â”€ â‚€ = 0

# Check if positive (> 0)
â•­â”€ isPositive : â„¤ â†’ Bool
â•°â”€ â‚€ > 0

# Check if negative (< 0)
â•­â”€ isNegative : â„¤ â†’ Bool
â•°â”€ â‚€ < 0

# Check if non-negative (>= 0)
â•­â”€ isNonNegative : â„¤ â†’ Bool
â•°â”€ â‚€ â‰¥ 0

# Check if non-positive (<= 0)
â•­â”€ isNonPositive : â„¤ â†’ Bool
â•°â”€ â‚€ â‰¤ 0

# Check if even
â•­â”€ isEven : â„¤ â†’ Bool
â•°â”€ â‚€ % 2 = 0

# Check if odd
â•­â”€ isOdd : â„¤ â†’ Bool
â•°â”€ â‚€ % 2 â‰  0

# Check if divisible by n
â•­â”€ isDivisibleBy : â„¤ â†’ â„¤ â†’ Bool
â•°â”€ â‚ % â‚€ = 0

# ============ Integer Operations ============

# Increment by 1
â•­â”€ inc : â„¤ â†’ â„¤
â•°â”€ â‚€ + 1

# Decrement by 1
â•­â”€ dec : â„¤ â†’ â„¤
â•°â”€ â‚€ - 1

# Negate integer
â•­â”€ negateInt : â„¤ â†’ â„¤
â•°â”€ 0 - â‚€

# Absolute value (integer)
â•­â”€ absInt : â„¤ â†’ â„¤
â•°â”€ if â‚€ < 0 then 0 - â‚€ else â‚€

# Sign of integer (-1, 0, or 1)
â•­â”€ signInt : â„¤ â†’ â„¤
â•°â”€ if â‚€ < 0 then -1
   else if â‚€ > 0 then 1
   else 0

# Integer division (truncates toward zero)
â•­â”€ divInt : â„¤ â†’ â„¤ â†’ â„¤
â•°â”€ â‚ / â‚€

# Integer modulo
â•­â”€ modInt : â„¤ â†’ â„¤ â†’ â„¤
â•°â”€ â‚ % â‚€

# Euclidean division (result always non-negative when divisor positive)
â•­â”€ divMod : â„¤ â†’ â„¤ â†’ âŸ¨â„¤, â„¤âŸ©
â•°â”€ âŸ¨â‚ / â‚€, â‚ % â‚€âŸ©

# ============ Float Operations ============

# Double a number
â•­â”€ double : F â†’ F
â•°â”€ â‚€ Ã— 2.0

# Halve a number
â•­â”€ half : F â†’ F
â•°â”€ â‚€ / 2.0

# Square a number
â•­â”€ square : F â†’ F
â•°â”€ â‚€ Ã— â‚€

# Cube a number
â•­â”€ cube : F â†’ F
â•°â”€ â‚€ Ã— â‚€ Ã— â‚€

# Negate a float
â•­â”€ negate : F â†’ F
â•°â”€ 0.0 - â‚€

# Reciprocal (1/x)
â•­â”€ recip : F â†’ F
â•°â”€ 1.0 / â‚€

# Absolute value (float)
â•­â”€ absF : F â†’ F
â•°â”€ if â‚€ < 0.0 then 0.0 - â‚€ else â‚€

# Sign of float (-1.0, 0.0, or 1.0)
â•­â”€ signF : F â†’ F
â•°â”€ if â‚€ < 0.0 then -1.0
   else if â‚€ > 0.0 then 1.0
   else 0.0

# Linear interpolation: lerp t a b = a + t*(b-a)
â•­â”€ lerp : F â†’ F â†’ F â†’ F
â•°â”€ â‚ + â‚‚ Ã— (â‚€ - â‚)

# Inverse lerp: what t gives this value between a and b?
â•­â”€ invLerp : F â†’ F â†’ F â†’ F
â•°â”€ (â‚‚ - â‚) / (â‚€ - â‚)

# Smooth step (cubic interpolation)
â•­â”€ smoothstep : F â†’ F â†’ F â†’ F
â•°â”€ let t = clamp ((â‚€ - â‚‚) / (â‚ - â‚‚)) 0.0 1.0
   in t Ã— t Ã— (3.0 - 2.0 Ã— t)

# ============ Rounding Operations ============

# Floor (round toward negative infinity)
â•­â”€ floor : F â†’ F
â•°â”€ âŒŠâ‚€âŒ‹

# Ceiling (round toward positive infinity)
â•­â”€ ceil : F â†’ F
â•°â”€ âŒˆâ‚€âŒ‰

# Round to nearest integer
â•­â”€ round : F â†’ F
â•°â”€ âŒŠâ‚€ + 0.5âŒ‹

# Truncate toward zero
â•­â”€ trunc : F â†’ F
â•°â”€ if â‚€ < 0.0 then âŒˆâ‚€âŒ‰ else âŒŠâ‚€âŒ‹

# Fractional part
â•­â”€ frac : F â†’ F
â•°â”€ â‚€ - âŒŠâ‚€âŒ‹

# ============ Trigonometric Functions ============
# Note: Built-in trig functions: sin, cos, tan, asin, acos, atan

# Secant
â•­â”€ sec : F â†’ F
â•°â”€ 1.0 / cos â‚€

# Cosecant
â•­â”€ csc : F â†’ F
â•°â”€ 1.0 / sin â‚€

# Cotangent
â•­â”€ cot : F â†’ F
â•°â”€ cos â‚€ / sin â‚€

# Convert degrees to radians
â•­â”€ toRadians : F â†’ F
â•°â”€ â‚€ Ã— Ï€ / 180.0

# Convert radians to degrees
â•­â”€ toDegrees : F â†’ F
â•°â”€ â‚€ Ã— 180.0 / Ï€

# ============ Exponential and Logarithmic ============
# Note: Built-in: exp, ln, logâ‚â‚€, logâ‚‚, âˆš

# Power of 2
â•­â”€ pow2 : F â†’ F
â•°â”€ 2.0 ^ â‚€

# Power of 10
â•­â”€ pow10 : F â†’ F
â•°â”€ 10.0 ^ â‚€

# Square root (alias)
â•­â”€ sqrt : F â†’ F
â•°â”€ âˆšâ‚€

# Cube root
â•­â”€ cbrt : F â†’ F
â•°â”€ â‚€ ^ (1.0 / 3.0)

# Natural logarithm (alias)
â•­â”€ log : F â†’ F
â•°â”€ ln â‚€

# Logarithm base b
â•­â”€ logBase : F â†’ F â†’ F
â•°â”€ ln â‚€ / ln â‚

# Hyperbolic functions are built-in: sinh, cosh, tanh

# ============ Array/List Basic Operations ============
# Note: head, length, sum, product, mean, minimum, maximum
# are defined in list.goth. Import that module for these.

# Check if empty
â•­â”€ isEmpty : [n]Î± â†’ Bool
â•°â”€ len â‚€ = 0

# Check if non-empty
â•­â”€ nonEmpty : [n]Î± â†’ Bool
â•°â”€ len â‚€ > 0

# ============ Mathematical Constants ============
# Built-in: Ï€ (pi), ğ•– (e)

# Tau = 2Ï€ (full circle in radians)
let tau = 2.0 Ã— Ï€

# Golden ratio Ï† = (1 + âˆš5) / 2
let phi = (1.0 + âˆš5.0) / 2.0

# Euler-Mascheroni constant (approximate)
let gamma = 0.5772156649015329

# Square root of 2
let sqrt2 = âˆš2.0

# Square root of 3
let sqrt3 = âˆš3.0

# Natural log of 2
let ln2 = ln 2.0

# Natural log of 10
let ln10 = ln 10.0

# ============ Tuple Operations ============

# Create a pair
â•­â”€ pair : Î± â†’ Î² â†’ âŸ¨Î±, Î²âŸ©
â•°â”€ âŸ¨â‚, â‚€âŸ©

# Get first element of pair
â•­â”€ fst : âŸ¨Î±, Î²âŸ© â†’ Î±
â•°â”€ â‚€.0

# Get second element of pair
â•­â”€ snd : âŸ¨Î±, Î²âŸ© â†’ Î²
â•°â”€ â‚€.1

# Swap elements of pair
â•­â”€ swap : âŸ¨Î±, Î²âŸ© â†’ âŸ¨Î², Î±âŸ©
â•°â”€ âŸ¨â‚€.1, â‚€.0âŸ©

# Apply function to first element
â•­â”€ mapFst : (Î± â†’ Î³) â†’ âŸ¨Î±, Î²âŸ© â†’ âŸ¨Î³, Î²âŸ©
â•°â”€ âŸ¨â‚ â‚€.0, â‚€.1âŸ©

# Apply function to second element
â•­â”€ mapSnd : (Î² â†’ Î³) â†’ âŸ¨Î±, Î²âŸ© â†’ âŸ¨Î±, Î³âŸ©
â•°â”€ âŸ¨â‚€.0, â‚ â‚€.1âŸ©

# Apply two functions to pair elements
â•­â”€ bimap : (Î± â†’ Î³) â†’ (Î² â†’ Î´) â†’ âŸ¨Î±, Î²âŸ© â†’ âŸ¨Î³, Î´âŸ©
â•°â”€ âŸ¨â‚‚ â‚€.0, â‚ â‚€.1âŸ©

# Duplicate value into pair
â•­â”€ dup : Î± â†’ âŸ¨Î±, Î±âŸ©
â•°â”€ âŸ¨â‚€, â‚€âŸ©

# Create triple
â•­â”€ triple : Î± â†’ Î² â†’ Î³ â†’ âŸ¨Î±, Î², Î³âŸ©
â•°â”€ âŸ¨â‚‚, â‚, â‚€âŸ©

# ============ Conditional Helpers ============

# If-then-else as function
â•­â”€ ifThenElse : Bool â†’ Î± â†’ Î± â†’ Î±
â•°â”€ if â‚‚ then â‚ else â‚€

# Guard: return value if condition true, else default
â•­â”€ guard : Bool â†’ Î± â†’ Î± â†’ Î±
â•°â”€ if â‚‚ then â‚ else â‚€

# Unless: opposite of when
â•­â”€ unless : Bool â†’ Î± â†’ Î± â†’ Î±
â•°â”€ if â‚‚ then â‚€ else â‚

# ============ Numeric Conversions ============

# Integer to float
â•­â”€ intToFloat : â„¤ â†’ F
â•°â”€ toFloat â‚€

# Float to integer (truncates)
â•­â”€ floatToInt : F â†’ â„¤
â•°â”€ toInt â‚€

# ============ Utility Functions ============

# Always returns unit (useful for side effects)
â•­â”€ unit : Î± â†’ âŸ¨âŸ©
â•°â”€ âŸ¨âŸ©

# Error/undefined placeholder (returns 0, use with caution)
â•­â”€ undefined : â„¤
â•°â”€ 0 / 0

# Assert-like: returns value if condition true
â•­â”€ ensuring : Bool â†’ Î± â†’ Î±
â•°â”€ if â‚ then â‚€ else â‚€
