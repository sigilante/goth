# Goth Standard Library - Result Type
# For computations that may succeed or fail with an error
#
# Result is encoded as a triple ⟨Bool, α, β⟩ where:
#   - ⟨⊤, value, _⟩ represents Ok(value)
#   - ⟨⊥, _, error⟩ represents Err(error)
#
# The first element (.0) is the "isOk" tag:
#   ⊤ → success, .1 holds the value
#   ⊥ → failure, .2 holds the error
#
# Unused slots hold 0 as a dead placeholder (never read by correct code).
# All functions are generic — the evaluator is type-erased at runtime.

# ============ Constructors ============

# Wrap a success value
╭─ ok : α → ⟨Bool, α, β⟩
╰─ ⟨⊤, ₀, 0⟩

# Wrap an error value
╭─ err : β → ⟨Bool, α, β⟩
╰─ ⟨⊥, 0, ₀⟩

# ============ Predicates ============

# Check if result is Ok
╭─ isOk : ⟨Bool, α, β⟩ → Bool
╰─ ₀.0

# Check if result is Err
╭─ isErr : ⟨Bool, α, β⟩ → Bool
╰─ ¬(₀.0)

# ============ Extractors ============

# Get Ok value or return default
╭─ unwrapOr : α → ⟨Bool, α, β⟩ → α
╰─ if ₀.0 then ₀.1 else ₁

# Get Err value or return default
╭─ unwrapErrOr : β → ⟨Bool, α, β⟩ → β
╰─ if ₀.0 then ₁ else ₀.2

# Get Ok value (unsafe — assumes Ok)
╭─ unsafeUnwrap : ⟨Bool, α, β⟩ → α
╰─ ₀.1

# Get Err value (unsafe — assumes Err)
╭─ unsafeUnwrapErr : ⟨Bool, α, β⟩ → β
╰─ ₀.2

# Get Ok value or compute default lazily
╭─ unwrapOrCompute : (⟨⟩ → α) → ⟨Bool, α, β⟩ → α
╰─ if ₀.0 then ₀.1 else ₁ ⟨⟩

# Get Ok value or compute from the error
╭─ unwrapOrElse : (β → α) → ⟨Bool, α, β⟩ → α
╰─ if ₀.0 then ₀.1 else ₁ ₀.2

# ============ Transformations ============

# Map function over Ok value
╭─ mapRes : (α → γ) → ⟨Bool, α, β⟩ → ⟨Bool, γ, β⟩
╰─ if ₀.0 then ⟨⊤, ₁ ₀.1, 0⟩ else ⟨⊥, 0, ₀.2⟩

# Map function over Err value
╭─ mapErr : (β → γ) → ⟨Bool, α, β⟩ → ⟨Bool, α, γ⟩
╰─ if ₀.0 then ⟨⊤, ₀.1, 0⟩ else ⟨⊥, 0, ₁ ₀.2⟩

# Map over both Ok and Err
╭─ bimapRes : (α → γ) → (β → δ) → ⟨Bool, α, β⟩ → ⟨Bool, γ, δ⟩
╰─ if ₀.0 then ⟨⊤, ₂ ₀.1, 0⟩ else ⟨⊥, 0, ₁ ₀.2⟩

# FlatMap / monadic bind on Ok
╭─ flatMapRes : (α → ⟨Bool, γ, β⟩) → ⟨Bool, α, β⟩ → ⟨Bool, γ, β⟩
╰─ if ₀.0 then ₁ ₀.1 else ⟨⊥, 0, ₀.2⟩

# FlatMap on Err
╭─ flatMapErr : (β → ⟨Bool, α, γ⟩) → ⟨Bool, α, β⟩ → ⟨Bool, α, γ⟩
╰─ if ₀.0 then ⟨⊤, ₀.1, 0⟩ else ₁ ₀.2

# ============ Combining Results ============

# Return first if Ok, else second
╭─ orElseRes : ⟨Bool, α, β⟩ → ⟨Bool, α, β⟩ → ⟨Bool, α, β⟩
╰─ if ₁.0 then ₁ else ₀

# Or else with function: compute alternative from error
╭─ orElseWith : (β → ⟨Bool, α, γ⟩) → ⟨Bool, α, β⟩ → ⟨Bool, α, γ⟩
╰─ if ₀.0 then ⟨⊤, ₀.1, 0⟩ else ₁ ₀.2

# Return second if first is Ok, else propagate first's error
╭─ andThenRes : ⟨Bool, α, β⟩ → ⟨Bool, γ, β⟩ → ⟨Bool, γ, β⟩
╰─ if ₁.0 then ₀ else ⟨⊥, 0, ₁.2⟩

# And: both must be Ok, keep first's value
╭─ andRes : ⟨Bool, α, β⟩ → ⟨Bool, γ, β⟩ → ⟨Bool, α, β⟩
╰─ if ₁.0 ∧ ₀.0 then ₁ else if ¬(₁.0) then ₁ else ⟨⊥, 0, ₀.2⟩

# Zip: Ok only if both Ok, combining values into a pair
╭─ zipRes : ⟨Bool, α, β⟩ → ⟨Bool, γ, β⟩ → ⟨Bool, ⟨α, γ⟩, β⟩
╰─ if ₁.0 ∧ ₀.0 then ⟨⊤, ⟨₁.1, ₀.1⟩, 0⟩
   else if ¬(₁.0) then ⟨⊥, 0, ₁.2⟩
   else ⟨⊥, 0, ₀.2⟩

# Zip with combining function
╭─ zipWithRes : (α → γ → δ) → ⟨Bool, α, β⟩ → ⟨Bool, γ, β⟩ → ⟨Bool, δ, β⟩
╰─ if ₁.0 ∧ ₀.0 then ⟨⊤, ₂ ₁.1 ₀.1, 0⟩
   else if ¬(₁.0) then ⟨⊥, 0, ₁.2⟩
   else ⟨⊥, 0, ₀.2⟩

# ============ Folding ============

# Fold: apply f to Ok value, or g to Err value
╭─ foldRes : (α → γ) → (β → γ) → ⟨Bool, α, β⟩ → γ
╰─ if ₀.0 then ₂ ₀.1 else ₁ ₀.2

# ============ Conversion ============

# Discard error, convert to Option
╭─ resToOpt : ⟨Bool, α, β⟩ → ⟨Bool, α⟩
╰─ ⟨₀.0, ₀.1⟩

# Convert Option to Result, providing error for None
╭─ optToRes : β → ⟨Bool, α⟩ → ⟨Bool, α, β⟩
╰─ if ₀.0 then ⟨⊤, ₀.1, 0⟩ else ⟨⊥, 0, ₁⟩

# Swap Ok and Err
╭─ swapRes : ⟨Bool, α, β⟩ → ⟨Bool, β, α⟩
╰─ ⟨¬(₀.0), ₀.2, ₀.1⟩

# Convert to list (empty or singleton with Ok value)
╭─ resToList : ⟨Bool, α, β⟩ → [n]α
╰─ if ₀.0 then [₀.1] else []

# ============ Boolean Checks ============

# Check if Ok contains specific value
╭─ containsRes : α → ⟨Bool, α, β⟩ → Bool
╰─ ₀.0 ∧ ₀.1 = ₁

# Check if Err contains specific error
╭─ containsErr : β → ⟨Bool, α, β⟩ → Bool
╰─ ¬(₀.0) ∧ ₀.2 = ₁

# Check if Ok value satisfies predicate
╭─ existsRes : (α → Bool) → ⟨Bool, α, β⟩ → Bool
╰─ ₀.0 ∧ ₁ ₀.1

# Check if Err value satisfies predicate
╭─ existsErr : (β → Bool) → ⟨Bool, α, β⟩ → Bool
╰─ ¬(₀.0) ∧ ₁ ₀.2

# Check if Err or Ok value satisfies predicate
╭─ forallRes : (α → Bool) → ⟨Bool, α, β⟩ → Bool
╰─ ¬(₀.0) ∨ ₁ ₀.1

# ============ Comparison ============

# Compare two results
╭─ eqRes : ⟨Bool, α, β⟩ → ⟨Bool, α, β⟩ → Bool
╰─ if ₁.0 ∧ ₀.0 then ₁.1 = ₀.1
   else if ¬(₁.0) ∧ ¬(₀.0) then ₁.2 = ₀.2
   else ⊥

# ============ Side Effects ============

# Apply function if Ok
╭─ forEachRes : (α → ⟨⟩) → ⟨Bool, α, β⟩ → ⟨⟩
╰─ if ₀.0 then ₁ ₀.1 else ⟨⟩

# Apply function if Err
╭─ forEachErr : (β → ⟨⟩) → ⟨Bool, α, β⟩ → ⟨⟩
╰─ if ₀.0 then ⟨⟩ else ₁ ₀.2

# Tap: side-effect on Ok value, return original
╭─ tapRes : (α → ⟨⟩) → ⟨Bool, α, β⟩ → ⟨Bool, α, β⟩
╰─ if ₀.0 then let _ = ₁ ₀.1 in ₀ else ₀

# ============ Safe Operations ============

# Safe division (Err with message on divide by zero)
╭─ safeDivRes : α → α → ⟨Bool, α, String⟩
╰─ if ₀ = 0 then ⟨⊥, 0, "division by zero"⟩ else ⟨⊤, ₁ / ₀, ""⟩

# Safe modulo
╭─ safeModRes : ℤ → ℤ → ⟨Bool, ℤ, String⟩
╰─ if ₀ = 0 then ⟨⊥, 0, "modulo by zero"⟩ else ⟨⊤, ₁ % ₀, ""⟩

# Safe square root
╭─ safeSqrtRes : F → ⟨Bool, F, String⟩
╰─ if ₀ < 0.0 then ⟨⊥, 0, "sqrt of negative"⟩ else ⟨⊤, √₀, ""⟩

# Safe log
╭─ safeLogRes : F → ⟨Bool, F, String⟩
╰─ if ₀ ≤ 0.0 then ⟨⊥, 0, "log of non-positive"⟩ else ⟨⊤, ln ₀, ""⟩

# Safe array index
╭─ safeIndexRes : ℤ → [n]α → ⟨Bool, α, String⟩
╰─ if ₁ < 0 then ⟨⊥, 0, "negative index"⟩
   else if ₁ ≥ len ₀ then ⟨⊥, 0, "index out of bounds"⟩
   else ⟨⊤, ₀[₁], ""⟩

# ============ Creating Results from Conditions ============

# Ok if condition true, else Err
╭─ okIf : Bool → α → β → ⟨Bool, α, β⟩
╰─ if ₂ then ⟨⊤, ₁, 0⟩ else ⟨⊥, 0, ₀⟩

# Ok if predicate passes on value, else Err
╭─ filterToRes : (α → Bool) → α → β → ⟨Bool, α, β⟩
╰─ if ₂ ₁ then ⟨⊤, ₁, 0⟩ else ⟨⊥, 0, ₀⟩

# Ensure Ok value satisfies predicate, else replace with Err
╭─ ensure : (α → Bool) → β → ⟨Bool, α, β⟩ → ⟨Bool, α, β⟩
╰─ if ₀.0 ∧ ₂ ₀.1 then ₀ else ⟨⊥, 0, ₁⟩

# ============ Error Handling Patterns ============

# Try: run function, recover from error with handler
╭─ try : (α → ⟨Bool, β, γ⟩) → (γ → β) → α → β
╰─ let res = ₂ ₀
   in if res.0 then res.1 else ₁ res.2

# Catch: unwrap Ok or return default on Err
╭─ catch : ⟨Bool, α, β⟩ → α → α
╰─ if ₁.0 then ₁.1 else ₀

# Recover: transform Err into Ok
╭─ recover : (β → α) → ⟨Bool, α, β⟩ → ⟨Bool, α, β⟩
╰─ if ₀.0 then ₀ else ⟨⊤, ₁ ₀.2, 0⟩

# Inspect error for side effect without changing the result
╭─ inspectErr : (β → ⟨⟩) → ⟨Bool, α, β⟩ → ⟨Bool, α, β⟩
╰─ if ₀.0 then ₀ else let _ = ₁ ₀.2 in ₀

# ============ String Representation ============

# Convert result to display string
╭─ showRes : ⟨Bool, α, β⟩ → String
╰─ if ₀.0 then "Ok(" ⧺ toString ₀.1 ⧺ ")"
   else "Err(" ⧺ toString ₀.2 ⧺ ")"
