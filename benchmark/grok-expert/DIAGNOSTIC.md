# Grok Expert Benchmark Diagnostic Report

This document analyzes the Goth code generated by Grok Expert to identify documentation gaps and language issues.

## Test Results Summary

### Category: basic

| File | Status | Error/Output |
|------|--------|--------------|
| abs | PASS | 5 |
| add_one | PASS | 6 |
| double | PASS | 10 |
| identity | PASS | 5 |
| is_even | FAIL (mod) | `mod` keyword not recognized |
| is_positive | PASS | ⊤ |
| max_two | PASS | <partial/1> |
| min_two | PASS | <partial/1> |
| sign | PASS | 1 |
| square | PASS | 25 |

### Category: recursion

| File | Status | Error/Output |
|------|--------|--------------|
| ackermann | PASS | <partial/1> |
| collatz_len | FAIL (mod) | `mod` keyword not recognized |
| digit_sum | PASS | 5 |
| factorial | PASS | 120 |
| fibonacci | PASS | 5 |
| gcd | PASS | <partial/1> |
| hyperop | PASS | <partial/2> |
| lcm | PASS | <partial/1> |
| mccarthy91 | PASS | 91 |
| power | PASS | <partial/1> |
| reverse_num | FAIL (mod) | `mod` keyword not recognized |
| sudan | PASS | <partial/2> |
| sum_to_n | PASS | 15 |
| tak | PASS | <partial/2> |

### Category: higher_order

| File | Status | Error/Output |
|------|--------|--------------|
| all_positive | PASS | ⊤ |
| any_negative | FAIL | Error: Type error: Cannot compare Int and Closure |
| apply_twice | FAIL (mod) | `mod` keyword not recognized |
| compose | FAIL (mod) | `mod` keyword not recognized |
| count_if | PASS | 0 |
| filter_positive | FAIL (parse) | Parse error |
| fold_product | FAIL | Error: Cannot multiply non-numeric tensor |
| fold_sum | PASS | 15 |
| map_double | FAIL (parse) | Parse error |
| pipeline | PASS | 0 |

### Category: numeric

| File | Status | Error/Output |
|------|--------|--------------|
| exp_taylor | FAIL | Error: Cannot sum non-numeric tensor |
| gamma_fact | PASS | 120.00000000000021 |
| gamma_half | PASS | 23.999999999999996 |
| harmonic | FAIL (float) | `float` function not found |
| pi_leibniz | FAIL (mod) | `mod` keyword not recognized |
| product_range | FAIL | Error: Cannot multiply non-numeric tensor |
| sqrt_newton | FAIL | Error: Undefined name: foldl |
| sum_squares | PASS | 55 |

### Category: algorithms

| File | Status | Error/Output |
|------|--------|--------------|
| binary_search | PASS | <partial/1> |
| count_primes | PASS | 0 |
| isPrime | FAIL (float) | `float` function not found |
| isqrt | FAIL (float) | `float` function not found |
| modpow | PASS | <partial/2> |
| nth_prime | FAIL (parse) | Parse error |


## Summary Statistics

- **Total files**: 48
- **Passing**: 31 (64%)
- **Failing**: 17 (36%)

### Failure Breakdown

| Issue | Count | Percentage |
|-------|-------|------------|
| `mod` keyword | 6 | 12% |
| `float` function | 3 | 6% |
| Parse errors | 3 | 6% |
| Other errors | 5 | 10% |

## Key Issues Identified

### 1. `mod` vs `%` Operator (6 failures)
Grok used `mod` for modulo operations (e.g., `₀ mod 2`), but Goth uses `%`.

**Recommendation**: Add `mod` as an alias for `%`, or prominently document that `%` is the modulo operator.

### 2. `float` Type Conversion (3 failures)
Grok used `float ₀` for int-to-float conversion, but this function doesn't exist.

**Recommendation**: Document the correct int-to-float conversion syntax, or add `float` builtin.

### 3. `[?]` Array Type Syntax (2 parse errors)
Grok used `[?]I64` for unknown-length arrays. This syntax is not recognized.

**Example**: `╭─ main : I64 → [?]I64` in filter_positive.goth

**Recommendation**: Document valid array type syntax (e.g., `[_]I64` or `[I64]`).

### 4. Named Lambda Parameters (1 parse error)
Grok used `λ n cnt p → ...` with named parameters. Goth lambdas use De Bruijn indices only.

**Example**: `let find_nth = λ n cnt p → if cnt = n then ...` in nth_prime.goth

**Recommendation**: Emphasize that Goth uses De Bruijn indices (`₀`, `₁`, `₂`) instead of named parameters.

### 5. De Bruijn Index Confusion in Nested Lambdas
In isPrime implementations, Grok wrote `λ→ ₀ mod (₀) = 0` which tests if `d % d = 0` (always true).
The intent was likely `₁ % ₀ = 0` to test if outer `n` is divisible by `d`.

**Recommendation**: Add more examples showing De Bruijn index behavior in nested lambdas.

### 6. `foldl` Builtin Missing (1 failure)
Grok used `foldl` for left-fold operations, but it's not available.

**Recommendation**: Document available reduction operators (`Σ`, `Π`) and their equivalences.

### 7. Tensor Operations with Closures (3 failures)
Some higher-order operations fail when tensors contain closures or when operations are applied incorrectly.

**Examples**:
- `any_negative`: "Cannot compare Int and Closure"
- `fold_product`: "Cannot multiply non-numeric tensor"
- `exp_taylor`: "Cannot sum non-numeric tensor"

**Recommendation**: Document which operations work with which tensor element types.

## Files With Issues (Details)

### algorithms/isPrime
```
# Is prime
# Precondition: n >= 2
╭─ main : I64 → Bool
╰─ let sqrt_n = ⌊ √ (float ₀) ⌋ in
     if ₀ < 2 then ⊥ else
     len (range 2 (sqrt_n + 1) ▸ (λ→ ₀ mod (₀) = 0)) = 0
```
**Error**: `Error: Undefined name: float`

### algorithms/isqrt
```
# Integer sqrt
╭─ main : I64 → I64
╰─ ⌊ √ (float ₀) ⌋
```
**Error**: `Error: Undefined name: float`

### algorithms/nth_prime
```
# Nth prime (find by counting)
╭─ main : I64 → I64
╰─ let find_nth = λ n cnt p → if cnt = n then p else find_nth n (cnt + if is_prime (p+1) then 1 else 0) (p+1) in
     find_nth ₀ 0 2
```
**Error**: `Load error: Parse error in /Users/neal/goth-master/benchmark/grok-expert/algorithms/nth_prime.goth: Unexpected token: Some(Ident("n")), expected Arrow`

### basic/is_even
```
# Even check
╭─ main : I64 → Bool
╰─ ₀ mod 2 = 0
```
**Error**: `Error: Type error: expected function, got Int`

### higher_order/any_negative
```
# Any negative in [-n .. n]
╭─ main : I64 → Bool
╰─ len (iota (₀ × 2 + 1) ↦ (λ→ ₀ - ₀)) ▸ (λ→ ₀ < 0) > 0
```
**Error**: `Error: Type error: Cannot compare Int and Closure`

### higher_order/apply_twice
```
# Apply double twice
╭─ main : I64 → I64
╰─ (λ→ ₀ × 2) ∘ (λ→ ₀ × 2) ₀
```
**Error**: `Error: Type error: expected function, got Int`

### higher_order/compose
```
# Compose square ∘ double
╭─ main : I64 → I64
╰─ (λ→ ₀ × ₀) ∘ (λ→ ₀ × 2) ₀
```
**Error**: `Error: Type error: expected function, got Int`

### higher_order/filter_positive
```
# Keep positive (generate [1..n])
# Precondition: n > 0
# Postcondition: all elements > 0, len(result) = n
╭─ main : I64 → [?]I64
╰─ iota ₀ ↦ (λ→ ₀ + 1)
```
**Error**: `Load error: Parse error in /Users/neal/goth-master/benchmark/grok-expert/higher_order/filter_positive.goth: Unexpected token: Some(Question), expected RBracket`

### higher_order/fold_product
```
# Product via fold (using Π)
# Property: result = n!
╭─ main : I64 → I64
╰─ Π (iota ₀ ↦ (λ→ ₀ + 1))
```
**Error**: `Error: Cannot multiply non-numeric tensor`

### higher_order/map_double
```
# Double list via map
# Precondition: n > 0
# Postcondition: len(result) = n, all elements even
╭─ main : I64 → [?]I64
╰─ (iota ₀ ↦ (λ→ ₀ + 1)) ↦ (λ→ ₀ × 2)
```
**Error**: `Load error: Parse error in /Users/neal/goth-master/benchmark/grok-expert/higher_order/map_double.goth: Unexpected token: Some(Question), expected RBracket`

### numeric/exp_taylor
```
# Exp Taylor: e^x ≈ Σ x^k / k! (k=0 to 20)
╭─ taylor_term : I64 → F64 → F64 → F64
╰─ (pow ₁ (float ₀)) / (Γ (float ₀ + 1.0))

╭─ main : F64 → F64
╰─ Σ (iota 20 ↦ (λ→ taylor_term ₀ ₁))
```
**Error**: `Error: Cannot sum non-numeric tensor`

### numeric/harmonic
```
# Harmonic number H(n)
╭─ main : I64 → F64
╰─ Σ ((iota ₀ ↦ (λ→ ₀ + 1)) ↦ (λ→ 1.0 / (float ₀)))
```
**Error**: `Error: Undefined name: float`

### numeric/pi_leibniz
```
# Pi Leibniz: 4 * Σ (-1)^k / (2k+1) k=0 to n
╭─ leibniz_term : I64 → F64
╰─ (if ₀ mod 2 = 0 then 1.0 else -1.0) / (2.0 × (float ₀) + 1.0)

╭─ main : I64 → F64
╰─ 4.0 × Σ (iota ₀ ↦ (λ→ leibniz_term ₀))
```
**Error**: `Error: Type error: expected function, got Int`

### numeric/product_range
```
# Product range: Π(1..n)
# Property: result = n!
╭─ main : I64 → I64
╰─ Π (iota ₀ ↦ (λ→ ₀ + 1))
```
**Error**: `Error: Cannot multiply non-numeric tensor`

### numeric/sqrt_newton
```
# Sqrt Newton-Raphson
╭─ newton_step : F64 → F64 → F64
╰─ ₀ - (₀ × ₀ - ₁) / (2.0 × ₀)

╭─ main : F64 → F64
╰─ let x0 = ₀ / 2.0 in
     foldl newton_step x0 (iota 10)
```
**Error**: `Error: Undefined name: foldl`

### recursion/collatz_len
```
# Collatz length: steps to 1
# Precondition: n > 0
╭─ main : I64 → I64
╰─ if ₀ = 1 then 0 else 1 + main (if ₀ mod 2 = 0 then ₀ / 2 else 3 × ₀ + 1)
```
**Error**: `Error: Type error: expected function, got Int`

### recursion/reverse_num
```
# Reverse number (with tail-recursive helper)
╭─ rev : I64 → I64 → I64
╰─ if ₁ = 0 then ₀ else rev (₁ / 10) (₀ × 10 + (₁ mod 10))

╭─ main : I64 → I64
╰─ rev ₀ 0
```
**Error**: `Error: Type error: expected function, got Int`

