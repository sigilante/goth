# Devstral Benchmark Diagnostic Report

This document analyzes the Goth code generated by Devstral to identify documentation gaps and language misunderstandings.

## Test Results Summary

| File | Status | Error |
|------|--------|-------|
| add | FAIL (parse) | `I64 × I64` tuple type syntax not supported |
| factorial | FAIL (no main) | Logic correct, missing main function |
| fibonacci | FAIL (no main) | Logic correct, missing main function |
| main | FAIL (parse) | `: → I64` empty input type invalid |
| multiply | FAIL (parse) | Mixed JSON/Goth syntax |
| safe_divide | FAIL (parse) | `try/catch` doesn't exist, tuple type |
| square | FAIL (parse) | Inline `⊨` postcondition syntax invalid |
| tco_factorial | FAIL (parse) | `fn(n, acc)` syntax doesn't exist |

## Summary Statistics

- **Total files**: 8
- **Passing**: 0 (0%)
- **Would pass with main wrapper**: 2 (25%)
- **Parse errors**: 6 (75%)

## Key Issues Identified

### 1. Tuple Type Syntax (4 files affected)

**Devstral wrote**:
```goth
╭─ add : I64 × I64 → I64
```

**Goth uses curried types**:
```goth
╭─ add : I64 → I64 → I64
```

Devstral confused tuple product types (`×`) with multi-argument function types.

### 2. Missing Main Function (2 files)

Devstral named functions `factorial`, `fibonacci` instead of `main`, or didn't include a main wrapper.

**Fix**: Either name the function `main` or add a main wrapper:
```goth
╭─ main : I64 → I64
╰─ factorial ₀
```

### 3. Empty Input Type (1 file)

**Devstral wrote**:
```goth
╭─ main : → I64
```

**Should be**:
```goth
╭─ main : I64 → I64
```

All functions must have at least one input type.

### 4. Inline Postconditions (1 file)

**Devstral wrote**:
```goth
╰─ let result = ₀ × ₀ in ⊨ result >= 0 && result == ₀ × ₀; result
```

**Correct postcondition syntax** (in function header):
```goth
╭─ square : I64 → I64
│  ⊨ ₀ >= 0
╰─ ₀ × ₀
```

### 5. Non-existent `fn()` Syntax (1 file)

**Devstral wrote**:
```goth
let helper = fn(n, acc) -> if n == 0 then acc else ...
```

**Goth uses lambdas with De Bruijn indices**:
```goth
let helper = λ→ if ₀ = 0 then ₁ else ...
```

### 6. Non-existent `try/catch` (1 file)

Goth does not have try/catch error handling. Devstral hallucinated this feature.

### 7. Mixed JSON/Goth Syntax (1 file)

Devstral wrote `{ "Idx": 1 } * { "Idx": 0 }` mixing JSON AST with Goth source.

## JSON AST Analysis

Devstral's JSON AST output is completely incompatible with Goth's format:

| Issue | Devstral | Correct Goth |
|-------|----------|--------------|
| If expression | `"If": ["<", ...]` array | `"If": {"cond":..., "then_":..., "else_":...}` |
| Function call | `"FnCall": [...]` | `"App": [func, arg]` (curried) |
| Signature | `"Tuple": [...], "return_type": ...` | `"Fn": [input, output]` (nested) |
| Precondition | `"precondition": [...]` | `"preconditions": [{"BinOp": ...}]` |
| Named params | `"params": ["n", "acc"]` | Not supported (De Bruijn only) |

## Comparison with Other LLMs

| LLM | Total Files | Pass Rate | Main Issues |
|-----|-------------|-----------|-------------|
| Grok Expert (code) | 48 | 64% | `mod` keyword |
| Grok Expert (JSON) | 48 | 50% | Currying format |
| **Devstral** | **8** | **0%** | Fundamental syntax misunderstanding |

## Conclusion

Devstral fundamentally misunderstood Goth's syntax despite being given documentation:

1. **Type system**: Confused tuples with curried functions
2. **Syntax**: Hallucinated features (`try/catch`, `fn()`, inline postconditions)
3. **JSON AST**: Invented incompatible structure instead of following examples
4. **Scale**: Only generated 8 examples vs 48 from Grok

The documentation may need to more explicitly state:
- Goth uses curried function types, not tuple argument types
- All programs need a `main` function
- Lambdas use De Bruijn indices, not named parameters
- JSON AST structure must exactly match the documented format
